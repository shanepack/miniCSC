// This file is designed to document the functionality of the MiniCSCData class in MiniCSCData.h. I recommend looking at
// the class beforehand to see the various methods and fields. It is all documented in the header file.
//
// You can run this example using `root MiniCSCDataExample.cpp`. Unfortunately due to root's interpreter and memory
// managment practices, you cannot use the `.x` execute function more than once. To get around this you must quit each
// time you restart the macro (this is mainly because of the header file, YMMV).
// TODO: Show how to get example file

// Include required headers
#include "MiniCSCData.h"

// TMP
#include <unistd.h>

// Define the root macro, notice the function name is the same as the file name
void MiniCSCDataExample()
{
    // Defining a root file to read
    // "./" says to look in the current directory (where you ran the script from)
    // "../" says to look in the parent directory
    // "~/" says to look in your user's home directory
    const char* rootFileName = "./example.root";

    // Create our data object. Currently I am allocating this on the stack. If you want to allocate on the heap you can
    // use the "new" operator. However, the object itself is mostly comprosed of pointers so stack allocation is enough
    // for most applications. See MiniCSCData::MiniCSCData() for information regarding the constructor and it's
    // parameters.
    //
    // I've set up this instance to open the "example.root" file. I've also defined both optional arguments but you can
    // rely on the defaults if you like.
    //
    // nullableGraphs is enabled, meaning if a getter function cannot find a graph, the returned histogram will be null.
    //     A value of false returns a empty histogram instead.
    // vectStartZero is enabled. This means the vectors of histogram pointers will start at 0, making layer numbers
    //     (1-6) not align with the histogram's index in the vector. If disabled, there is a nullptr at position zero
    //     meaning for loops can be a little more difficult to use.
    MiniCSCData data(rootFileName, true, true);

    // Basic usage ====================================================================================================
    // I will not go into too much detail about the Root related code, Root has a ton of public information to peruse.

    // TODO: Link to the EDM plugin
    //
    // We can use the various getters to get histograms generated by the MiniCSC EDM plugin. Depending on the getter,
    // you can either recieve a std::vector<> of histogram pointers or a pointer to a histogram. This mainly depends on
    // if the EDM plugin outputs a plot for every layer or if it consolidates all layers into one. See the getter method
    // documentation to find what types to expect.
    //
    // This graph is similar to the clusters charge graph on the DQM plots. There is one graph for each active layer
    // (most likely 1 or 2 but max 6). any layers that are not active will have a nullptr or empty histogram depending
    // on how you constructed the MiniCSCData instance.
    std::vector<TH1D*> chargeSpectraHistAll = data.ChargeSpectra();

    // Get layer 3's charge spectra graph.
    // NOTE: Since I did not disable vectStartZero the vector starts filling graphs at index 0 (layer 3 - 1).
    TH1D* chargeSpectraL3 = chargeSpectraHistAll[2];
    // If you were to draw this graph you would notice a lot of noise and strange spikes. We will do some data treatment
    // first.

    // First we rebin, making each bin (x axis tick) wider. This removes some noise and makes it overall more readable.
    chargeSpectraL3->Rebin(32);
    // Then we chop off the first 100 bins, this is because there is a large spike which is most likely noise at the
    // beginning. The upper bound of 4000.5 removes the tail at the end of the graph which does not have much useful
    // data. We add 0.5 to each bound to align bin indexies with the center of the bin, this is more noticable with
    // fewer bins.
    chargeSpectraL3->GetXaxis()->SetRangeUser(100.5, 4000.5);
    // Then we set the title, since a lot of the root file histograms have titles that are less than useful when
    // presenting the plots.
    chargeSpectraL3->SetTitle("Charge Spectra");

    // Finally we draw
    chargeSpectraL3->Draw();

    // Now that we've covered the basics, I will explain some more niche functionality. Theoretically you shouldn't need
    // to use this if future plots are created properly.

    // You can use MiniCSCData::GetGraph to retrieve a graph from the root file. This only works if you know the full
    // path and name of the graph within the root file. Here I am retrieving the wire occupancy plot for layer 5.
    // NOTE: Graphs with multiple layers will always have layers start at 1.
    TH1D* wireOcc = data.GetGraph<TH1D>("/Anode/wire/wireL5");
    // wireOcc->Draw();

    // We can also get the graph using it's MiniCSCData::Graph name. These graph names are meant to be a more human
    // readable version of graph ids or something similar. Each enum member is documented in MiniCSCData.h and depending
    // on your editor of choice, hovering over the name should show you the comment for quick reference.
    TProfile* chargeTBin = data.GetGraph<TProfile>(MiniCSCData::Graph::kchargeTBinProfile);
    // chargeTBin->Draw();
}
